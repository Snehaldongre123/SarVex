ðŸš€ PHASE 0 â€” Define System Architecture (Day 1)
Final Architecture

Frontend (Behavior Capture JS)
â†’ Backend API (FastAPI/Django)
â†’ PostgreSQL (Store features)
â†’ Feature Engineering Layer
â†’ Vertex AI Model
â†’ Trust Score API
â†’ Access Decision Engine

Keep it simple.

ðŸš€ PHASE 1 â€” Basic Working System (No AI Yet)
ðŸŽ¯ Goal: Collect & Store Clean Behavior Data
Step 1 â€” Create Backend API

FastAPI project

Endpoints:

/register

/login

/save_behavior

Step 2 â€” Create Database Schema

Table: user_behavior

Fields:

user_id

typing_speed

key_hold_time_avg

mouse_velocity_avg

click_interval_avg

scroll_depth_avg

latency_avg

device_hash

location_hash

timestamp

label

Step 3 â€” Build Frontend Behavior Capture

Implement:

Keystroke timing

Mouse movement sampling

Click interval tracking

Scroll depth %

Network latency ping

Convert raw logs â†’ numeric features.

Send features to backend on login/register.

Step 4 â€” Store Only Engineered Features

DO NOT store raw events.

Store:

Averages

Standard deviation

Speed metrics

Now system works without AI.

ðŸš€ PHASE 2 â€” Build Rule-Based Trust Engine

Before ML, build rule logic.

Example:

if typing_speed_diff < 20% 
and device_match == true
and location_match == true:
    allow_login
else:
    limited_access

This gives working demo.

Judges love working systems.

ðŸš€ PHASE 3 â€” Prepare ML Dataset

Now collect:

At least:

100â€“500 sessions per user

5â€“10 simulated anomaly sessions

Label:

1 = genuine

0 = anomaly

Export CSV.

Columns example:

typing_speed,
key_hold_time,
mouse_velocity,
click_interval,
scroll_depth,
latency,
time_of_day,
device_match,
label
ðŸš€ PHASE 4 â€” Vertex AI Training
Step 1

Upload dataset to BigQuery.

Step 2

Go to Vertex AI â†’ AutoML Tabular.

Select:

Classification

Target column = label

Optimization = AUC

Train with CPU only.

ðŸš€ PHASE 5 â€” Deploy Model

After training:

Deploy endpoint

Get REST API URL

Backend will:

Receive login behavior

Send feature JSON to Vertex endpoint

Receive prediction probability

If score > threshold â†’ allow

ðŸš€ PHASE 6 â€” Build Trust Score Engine

Combine:

ML Score (60%)
Device Match (20%)
Location Pattern (10%)
Time Pattern (10%)

Final Trust Score = weighted sum.

This makes system robust.

ðŸš€ PHASE 7 â€” Recovery Mode Layer

If trust score < threshold:

Trigger:

Limited access mode

Behavioral challenge

Trusted contact approval

ðŸš€ PHASE 8 â€” Optimization for Hackathon

Add:

Real-time dashboard

Graph of trust score

Login attempt heatmap

Behavior deviation chart

This impresses judges.

ðŸ§  Final Development Timeline (Realistic)

Week 1:
Backend + Data Collection

Week 2:
Feature Engineering + Rule Engine

Week 3:
Vertex AI Training + Deployment

Week 4:
Trust Engine + Recovery Mode + UI polish

ðŸ”¥ Tech Stack Final

Frontend: JS + React
Backend: FastAPI
DB: PostgreSQL
ML: Vertex AI AutoML
Cloud: GCP